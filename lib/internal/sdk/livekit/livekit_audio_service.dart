import 'dart:async';
import 'dart:math' as math;
import 'package:flutter/foundation.dart';
import 'package:livekit_client/livekit_client.dart' as lk;
import 'package:lklk/internal/sdk/livekit/voice_activity_controller.dart';
import 'package:lklk/core/config/app_config.dart';
import 'package:lklk/core/utils/logger.dart';

/// LiveKit audio service to migrate Zego audio logic 1:1 without changing
/// public Cubit interfaces. ExpressService will delegate to this when enabled.
class LiveKitAudioService {
  LiveKitAudioService._();
  static final LiveKitAudioService instance = LiveKitAudioService._();

  // Runtime switch: when true, ExpressService will delegate audio ops to LiveKit
  bool enabled = false;

  // Connection state
  String currentRoomID = '';
  String? serverUrl; // e.g. https://livekit.yourdomain.com
  String? _token; // LiveKit JWT generated by backend for the current user

  lk.Room? _room;
  lk.EventsListener<lk.RoomEvent>? _listener;
  VoiceActivityController? _vac;
  StreamSubscription<Map<String, double>>? _vacSub;
  Timer? _levelsTimer;
  Timer? _micKeepalive;
  final Set<String> _activeSpeakers = {};
  // Only identities present in this set will be subscribed to for remote audio.
  // If empty, default behavior is to subscribe to all (backward compatible).
  final Set<String> _allowedRemoteSpeakers = {};
  bool _localMicEnabled = false;
  bool get isLocalMicEnabled => _localMicEnabled;
  // Notifier for UI to reflect mic state immediately
  final ValueNotifier<bool> localMicNotifier = ValueNotifier<bool>(false);
  DateTime? _lastLocalVoiceAt;

  // ---------------------------- Audio level plumbing ------------------------
  // Real-time per-identity sound level (0.0..1.0). Keys are LiveKit identities
  // which should equal UserEntity.iduser (token identity).
  final Map<String, ValueNotifier<double>> userSoundLevels = <String, ValueNotifier<double>>{};
  final List<void Function(Map<String, double>)> _remoteLevelListeners = [];
  // Hold per-participant audio level listeners to detach later
  final Map<String, _ParticipantLevelObserver> _participantLevelObservers = {};
  // VAD gate state with hysteresis to avoid lingering wave when quiet
  final Map<String, bool> _vadGateOpen = {};
  final Map<String, int> _vadOpenStreak = {};
  final Map<String, int> _vadCloseStreak = {};

  void addRemoteSoundLevelListener(void Function(Map<String, double>) listener) {
    if (!_remoteLevelListeners.contains(listener)) {
      _remoteLevelListeners.add(listener);
    }
  }

  // Update a per-identity VAD gate with hysteresis.
  // Opens after 'openN' consecutive frames >= openThr, closes after 'closeN' consecutive frames <= closeThr.
  bool _updateVADGate(
    String id,
    double target, {
    double openThr = 0.16,
    double closeThr = 0.10,
    int openN = 1,
    int closeN = 2,
  }) {
    final bool wasOpen = _vadGateOpen[id] ?? false;
    if (wasOpen) {
      // If gate is open and we are clearly quiet, increment close streak
      if (target <= closeThr) {
        final c = (_vadCloseStreak[id] ?? 0) + 1;
        _vadCloseStreak[id] = c;
        if (c >= closeN) {
          _vadGateOpen[id] = false;
          _vadOpenStreak[id] = 0;
          _vadCloseStreak[id] = 0;
          if (AppConfig.enableLogging) {
            AppLogger.debug('LK gate id=$id -> CLOSE (target=${target.toStringAsFixed(3)})', tag: 'LiveKitAudioService');
          }
        }
      } else {
        // Reset close streak while energy is above close threshold
        _vadCloseStreak[id] = 0;
      }
    } else {
      // If gate is closed and we have strong enough energy, increment open streak
      if (target >= openThr) {
        final o = (_vadOpenStreak[id] ?? 0) + 1;
        _vadOpenStreak[id] = o;
        if (o >= openN) {
          _vadGateOpen[id] = true;
          _vadOpenStreak[id] = 0;
          _vadCloseStreak[id] = 0;
          if (AppConfig.enableLogging) {
            AppLogger.debug('LK gate id=$id -> OPEN (target=${target.toStringAsFixed(3)})', tag: 'LiveKitAudioService');
          }
        }
      } else {
        // Reset open streak while below open threshold
        _vadOpenStreak[id] = 0;
      }
    }
    return _vadGateOpen[id] ?? false;
  }

  void removeRemoteSoundLevelListener(void Function(Map<String, double>) listener) {
    _remoteLevelListeners.remove(listener);
  }

  // Attach a ChangeNotifier listener to a participant to observe audioLevel.
  void _attachParticipantLevelObserver(lk.Participant p) {
    final id = p.identity;
    // Detach any existing observer for this identity first
    final existing = _participantLevelObservers.remove(id);
    if (existing != null) {
      try { existing.p.removeListener(existing.cb); } catch (_) {}
    }
    void cb() {
      try {
        final raw = p.audioLevel; // 0..1 from SDK
        final n = userSoundLevels.putIfAbsent(id, () => ValueNotifier<double>(0.0));
        final room = _room;
        final bool isLocal = (p is lk.LocalParticipant) ||
            (room?.localParticipant?.identity == p.identity);
        // If local mic is disabled, force level to 0 immediately
        if (isLocal && !_localMicEnabled) {
          if (n.value != 0.0) {
            n.value = 0.0;
            _emitRemoteLevels({id: 0.0});
          }
          return;
        }
        // Gate by local mic state / remote subscription; VAD will handle speech onset
        bool hasRemoteSubscribed = true;
        if (!isLocal) {
          try {
            hasRemoteSubscribed = p.audioTrackPublications.any((pub) => pub.subscribed);
          } catch (_) {}
        }
        final bool allowed = isLocal ? _localMicEnabled : hasRemoteSubscribed;
        final targetRaw = allowed ? raw : 0.0;
        final targetNorm = _normalizeLevel(targetRaw);
        final bool prevGate = _vadGateOpen[id] ?? false;
        final gateOpen = _updateVADGate(id, targetNorm);
        bool justOpened = gateOpen && !prevGate;
        double target = gateOpen ? targetNorm : 0.0;
        // Ensure instant visual when speech starts: small lift above 0.25 on open
        if (justOpened && target < 0.25) {
          target = 0.28;
        }
        final prev = n.value;
        final smoothed = _smoothLevel(prev, target);
        final bool changed = (smoothed - prev).abs() > 0.001;
        if (changed) {
          n.value = smoothed;
        }
        if (AppConfig.enableLogging && (changed || targetNorm > 0.18 || justOpened)) {
          final bool active = _activeSpeakers.contains(id);
          final bool subscribed = isLocal ? _localMicEnabled : hasRemoteSubscribed;
          AppLogger.debug(
            'LK meter id=$id local=$isLocal raw=${raw.toStringAsFixed(3)} norm=${targetNorm.toStringAsFixed(3)} gate=$gateOpen justOpen=$justOpened target=${target.toStringAsFixed(3)} smooth=${smoothed.toStringAsFixed(3)} allowed=$allowed subscribed=$subscribed active=$active',
            tag: 'LiveKitAudioService',
          );
        }
        if (p == _room?.localParticipant && smoothed > 0.001) {
          _lastLocalVoiceAt = DateTime.now();
        }
        _emitRemoteLevels({id: n.value});
      } catch (_) {}
    }
    try { p.addListener(cb); } catch (_) {}
    _participantLevelObservers[id] = _ParticipantLevelObserver(p, cb);
    // Emit an initial value immediately so UI reflects current state
    cb();
  }

  void _detachParticipantLevelObserver(String identity) {
    final obs = _participantLevelObservers.remove(identity);
    if (obs != null) {
      try { obs.p.removeListener(obs.cb); } catch (_) {}
    }
  }

  void _emitRemoteLevels(Map<String, double> levels) {
    // Legacy single-listener
    try { onRemoteSoundLevelUpdate?.call(levels); } catch (_) {}
    // Fan-out to multiple listeners
    for (final l in List.from(_remoteLevelListeners)) {
      try { l(levels); } catch (_) {}
    }
  }

  // Event callbacks to bridge into existing app (same timing/semantics)
  void Function(String roomID, String state, int errorCode,
      Map<String, dynamic> extendedData)? onRoomStateChanged;
  void Function(Map<String, double> soundLevels)? onRemoteSoundLevelUpdate;
  void Function(double soundLevel)? onCapturedSoundLevelUpdate;
  void Function(String participantId, bool speaking)?
      onParticipantSpeakingChanged;
  void Function(String participantId, bool added)? onParticipantPresenceChanged;
  void Function(String participantId, String trackSid, bool subscribed)?
      onAudioTrackSubscription;

  // ----------------------------- Configuration -----------------------------
  Future<void> configure({required String serverUrl}) async {
    this.serverUrl = serverUrl;
  }

  // Normalize: simple noise-floor gate + soft shaping in [0..1].
  // LiveKit's audioLevel is already 0..1; we avoid dB conversion to prevent overshoot.
  double _normalizeLevel(double level) {
    const double noiseFloor = 0.008; // lower floor for higher sensitivity
    if (level <= noiseFloor) return 0.0;
    double norm = (level - noiseFloor) / (1.0 - noiseFloor);
    // Soft shaping to gently boost without saturating
    norm = math.pow(norm, 0.70).toDouble();
    return norm.clamp(0.0, 0.98);
  }

  // Attack/Release smoothing for immediate yet stable visuals.
  double _smoothLevel(double previous, double target) {
    // Threshold-aware: if we just crossed the UI threshold (0.25), jump immediately
    if (previous <= 0.25 && target > 0.25) {
      return target;
    }
    // If dropping well below threshold, allow an immediate drop to avoid lingering
    if (previous > 0.25 && target < 0.18) {
      return target;
    }
    // Faster attack for rises, slower release for falls
    const double attack = 1.0;   // immediate rise
    const double release = 0.35; // faster decay than before to avoid sticking
    final double alpha = target > previous ? attack : release;
    return previous + (target - previous) * alpha;
  }

  // ------------------------------ Mic keepalive -----------------------------
  void _startMicKeepalive({
    Duration interval = const Duration(seconds: 20),
    Duration staleThreshold = const Duration(seconds: 30),
  }) {
    _micKeepalive?.cancel();
    _micKeepalive = Timer.periodic(interval, (_) async {
      try {
        if (!_localMicEnabled) return;
        final last = _lastLocalVoiceAt;
        if (last == null) return;
        final now = DateTime.now();
        if (now.difference(last) > staleThreshold) {
          if (AppConfig.enableLogging) {
            AppLogger.info(
                'Mic keepalive: reasserting mic (stale>${staleThreshold.inSeconds}s)',
                tag: 'LiveKitAudioService');
          }
          await setMicrophoneEnabled(true, reason: 'keepalive', force: true);
        }
      } catch (_) {}
    });
  }

  Future<void> _forceStopLocalAudioTracks() async {
    final room = _room;
    if (room == null) return;
    final local = room.localParticipant;
    if (local == null) return;
    try {
      for (final pub in local.audioTrackPublications) {
        try { await pub.track?.stop(); } catch (_) {}
      }
    } catch (_) {}
  }

  Future<void> connectUser(
      {required String userId, required String userName}) async {
    // No-op for LiveKit; identity comes from the server-issued JWT (token)
  }

  // ------------------------------- Room join --------------------------------
  Future<void> loginRoom(String roomID, {required String token}) async {
    if (serverUrl == null || serverUrl!.isEmpty) {
      // Cannot connect without server url
      return;
    }
    // Disconnect any previous room
    await logoutRoom();

    currentRoomID = roomID;
    _token = token;
    // Reset local mic state for new join
    _localMicEnabled = false;
    try { localMicNotifier.value = false; } catch (_) {}

    final options = lk.RoomOptions(
      adaptiveStream: true,
      dynacast: true,
      // Keep audio active in background; routing controlled by OS/Hardware
    );
    final connectOptions = const lk.ConnectOptions();
    if (AppConfig.enableLogging) {
      AppLogger.info(
        'LiveKit connecting: url=$serverUrl room=$roomID',
        tag: 'LiveKitAudioService',
      );
    }
    final room = lk.Room();
    try {
      await room.connect(
        serverUrl!,
        token,
        roomOptions: options,
        connectOptions: connectOptions,
      );
      _room = room;
    } catch (e) {
      AppLogger.error('LiveKit connect failed', tag: 'LiveKitAudioService', error: e as Object?);
      rethrow;
    }

    // Notify connected
    onRoomStateChanged?.call(roomID, 'Connected', 0, {
      'sdk': 'livekit',
    });

    // Setup listeners
    _listener = _room!.createListener();
    _listener!
      ..on<lk.RoomDisconnectedEvent>((e) {
        onRoomStateChanged?.call(currentRoomID, 'Disconnected', 0, {
          'sdk': 'livekit',
          'reason': e.reason.toString(),
        });
        if (AppConfig.enableLogging) {
          AppLogger.info('LiveKit disconnected: reason=${e.reason}', tag: 'LiveKitAudioService');
        }
      })
      ..on<lk.ParticipantConnectedEvent>((e) {
        onParticipantPresenceChanged?.call(e.participant.identity, true);
        // Apply subscription policy based on allowed speakers
        _applySubscriptionForParticipant(e.participant.identity);
        // Initialize notifier for this identity
        userSoundLevels.putIfAbsent(e.participant.identity, () => ValueNotifier<double>(0.0));
        // Levels will be streamed via VoiceActivityController
      })
      ..on<lk.ParticipantDisconnectedEvent>((e) {
        onParticipantPresenceChanged?.call(e.participant.identity, false);
        // Cleanup notifier for this identity
        try { userSoundLevels.remove(e.participant.identity)?.dispose(); } catch (_) {}
        // Detach audio level observer
        _detachParticipantLevelObserver(e.participant.identity);
      })
      ..on<lk.TrackPublishedEvent>((e) {
        // Subscribe only if participant is allowed (speaker/host)
        if (e.publication.kind == lk.TrackType.AUDIO) {
          final id = e.participant.identity;
          final allowed = _isAllowed(id);
          final isBot = id.startsWith('musicbot_');
          if (allowed || isBot) {
            try {
              e.publication.subscribe();
              if (AppConfig.enableLogging && isBot) {
                AppLogger.info('Force-subscribed to music bot audio: participant=$id sid=${e.publication.sid}',
                    tag: 'LiveKitAudioService');
              }
            } catch (_) {}
          }
        }
      })
      ..on<lk.TrackSubscribedEvent>((e) {
        if (e.publication.kind == lk.TrackType.AUDIO) {
          onAudioTrackSubscription?.call(
              e.participant.identity, e.publication.sid, true);
          if (AppConfig.enableLogging) {
            AppLogger.info('Subscribed to remote audio: participant=${e.participant.identity} sid=${e.publication.sid}',
                tag: 'LiveKitAudioService');
          }
        }
      })
      ..on<lk.TrackUnsubscribedEvent>((e) {
        if (e.publication.kind == lk.TrackType.AUDIO) {
          onAudioTrackSubscription?.call(
              e.participant.identity, e.publication.sid, false);
        }
      })
      ..on<lk.ActiveSpeakersChangedEvent>((e) {
        try {
          final current = e.speakers.map((p) => p.identity).toSet();
          // newly speaking
          for (final id in current.difference(_activeSpeakers)) {
            onParticipantSpeakingChanged?.call(id, true);
          }
          // no longer speaking
          for (final id in _activeSpeakers.difference(current)) {
            onParticipantSpeakingChanged?.call(id, false);
          }
          _activeSpeakers
            ..clear()
            ..addAll(current);
          // Emit levels ONLY for current active speakers to guarantee instant UI wake.
          // Do NOT zero non-speakers here (VAC/per-observer will decay them).
          final parts = participantsSnapshot();
          final idx = {for (final p in parts) p.identity: p};
          final map = <String, double>{};
          for (final id in current) {
            final p = idx[id];
            if (p == null) continue;
            double raw = p.audioLevel;
            final room = _room;
            final bool isLocal = (p is lk.LocalParticipant) ||
                (room?.localParticipant?.identity == p.identity);
            if (isLocal && !_localMicEnabled) raw = 0.0;
            final norm = _normalizeLevel(raw);
            double target = norm;
            // Ensure instant visible start from quiet, regardless of norm floor
            final n = userSoundLevels.putIfAbsent(id, () => ValueNotifier<double>(0.0));
            if (n.value <= 0.25) {
              if (target < 0.32) target = 0.32;
            }
            final prev = n.value;
            final smooth = _smoothLevel(prev, target);
            if (n.value != smooth) n.value = smooth;
            map[id] = smooth;
            if (AppConfig.enableLogging) {
              AppLogger.debug(
                'LK meter(ev) id=$id local=$isLocal raw=${raw.toStringAsFixed(3)} norm=${norm.toStringAsFixed(3)} target=${target.toStringAsFixed(3)} smooth=${smooth.toStringAsFixed(3)}',
                tag: 'LiveKitAudioService',
              );
            }
          }
          if (map.isNotEmpty) _emitRemoteLevels(map);
        } catch (_) {}
      });

    // Force speaker route ON by default for room audio
    try { await setSpeakerEnabled(true); } catch (_) {}

    // Ensure we are subscribed according to current policy for existing remotes
    try { _applySubscriptionsForAll(); } catch (_) {}

    // Start mic keepalive watchdog
    _startMicKeepalive();

    // Initialize level notifiers for current participants (levels pushed by VAC)
    for (final p in participantsSnapshot()) {
      userSoundLevels.putIfAbsent(p.identity, () => ValueNotifier<double>(0.0));
    }

    // Start centralized VoiceActivityController and bind to UI
    _vac?.dispose();
    _vacSub?.cancel();
    _vac = VoiceActivityController(
      room: _room!,
      isLocalMicOn: () => _localMicEnabled,
    )..start();
    _vacSub = _vac!.levelsStream.listen((map) {
      try {
        final out = <String, double>{};
        map.forEach((id, level) {
          final n = userSoundLevels.putIfAbsent(id, () => ValueNotifier<double>(0.0));
          if (n.value != level) {
            n.value = level;
          }
          out[id] = level;
          // Track local activity for keepalive
          final lp = _room?.localParticipant;
          if (lp != null && lp.identity == id && level > 0.001) {
            _lastLocalVoiceAt = DateTime.now();
          }
        });
        if (out.isNotEmpty) _emitRemoteLevels(out);
      } catch (_) {}
    });
  }

  Future<void> logoutRoom() async {
    // Dispose VAC first to stop streams
    try { await _vacSub?.cancel(); } catch (_) {}
    _vacSub = null;
    try { _vac?.dispose(); } catch (_) {}
    _vac = null;
    _levelsTimer?.cancel();
    _levelsTimer = null;
    _micKeepalive?.cancel();
    _micKeepalive = null;
    // Proactively disable local mic before disconnect to avoid residual capture
    try {
      await _room?.localParticipant?.setMicrophoneEnabled(false);
    } catch (_) {}
    _localMicEnabled = false;
    try { localMicNotifier.value = false; } catch (_) {}
    // Extra safety: stop any remaining local audio tracks
    await _forceStopLocalAudioTracks();
    try {
      await _listener?.dispose();
    } catch (_) {}
    _listener = null;
    try {
      await _room?.disconnect();
    } catch (_) {}
    _room = null;
    // Clear audio level state
    try { for (final n in userSoundLevels.values) { n.dispose(); } } catch (_) {}
    userSoundLevels.clear();
    // Detach all participant observers
    try {
      for (final entry in _participantLevelObservers.entries) {
        try { entry.value.p.removeListener(entry.value.cb); } catch (_) {}
      }
    } catch (_) {}
    _participantLevelObservers.clear();
    if (currentRoomID.isNotEmpty) {
      onRoomStateChanged?.call(currentRoomID, 'Disconnected', 0, {
        'sdk': 'livekit',
        'reason': 'manual-logout',
      });
    }
    currentRoomID = '';
  }

  // ------------------------------ Audio control -----------------------------
  Future<void> setMicrophoneEnabled(bool enable,
      {String reason = 'unspecified', bool force = false}) async {
    if (_localMicEnabled == enable && !force) {
      if (AppConfig.enableLogging) {
        AppLogger.info(
            'setMicrophoneEnabled($enable) skipped (no change), reason=$reason',
            tag: 'LiveKitAudioService');
      }
      return;
    }
    final prev = _localMicEnabled;
    // Optimistically update UI immediately
    _localMicEnabled = enable;
    try {
      localMicNotifier.value = enable;
    } catch (_) {}
    try {
      await _room?.localParticipant?.setMicrophoneEnabled(enable);
      if (!enable) {
        // Extra safety: stop any pre-existing local tracks
        await _forceStopLocalAudioTracks();
      }
      if (AppConfig.enableLogging) {
        AppLogger.info('Local microphone set to $enable (reason=$reason)',
            tag: 'LiveKitAudioService');
      }
      // Reassert speaker route and subscriptions so remote music never drops due to mode changes
      try { await setSpeakerEnabled(true); } catch (_) {}
      try { _applySubscriptionsForAll(); } catch (_) {}
      if (enable) {
        _lastLocalVoiceAt = DateTime.now();
      }
    } catch (e) {
      // Revert on failure
      _localMicEnabled = prev;
      try {
        localMicNotifier.value = prev;
      } catch (_) {}
      if (AppConfig.enableLogging) {
        AppLogger.error('Failed setMicrophoneEnabled($enable) (reason=$reason)',
            tag: 'LiveKitAudioService', error: e as Object?);
      }
    }
  }

  Future<void> setSpeakerEnabled(bool enable) async {
    try {
      // Prefer room extension if available
      // ignore: deprecated_member_use_from_same_package
      await _room?.setSpeakerOn(enable);
    } catch (_) {
      try {
        await lk.Hardware.instance.setSpeakerphoneOn(enable);
      } catch (_) {}
    }
  }

  // ---------------------------- Sound level monitor -------------------------
  Future<void> startSoundLevelMonitor({
    Duration interval = const Duration(milliseconds: 1000),
  }) async {
    // Event-driven via ActiveSpeakersChangedEvent; no polling timer needed.
    _levelsTimer?.cancel();
    _levelsTimer = null;
  }

  Future<void> stopSoundLevelMonitor() async {
    _levelsTimer?.cancel();
    _levelsTimer = null;
  }

  // ----------------------------- Participants snapshot ----------------------
  List<lk.Participant> participantsSnapshot() {
    final room = _room;
    if (room == null) return const <lk.Participant>[];
    final list = <lk.Participant>[];
    final local = room.localParticipant;
    if (local != null) list.add(local);
    list.addAll(room.remoteParticipants.values);
    return list;
  }

  // ----------------------------- Playback helpers ---------------------------
  Future<void> restartRemoteAudio(String participantIdentity) async {
    final room = _room;
    if (room == null) return;
    final p = room.remoteParticipants[participantIdentity];
    if (p == null) return;
    try {
      // Toggle all audio publications to force refresh
      for (final pub in p.audioTrackPublications) {
        if (pub.subscribed) {
          await pub.unsubscribe();
          await Future<void>.delayed(const Duration(milliseconds: 100));
          await pub.subscribe();
        } else {
          await pub.subscribe();
        }
      }
    } catch (_) {}
  }

  // ------------------------- Remote subscription control --------------------
  Future<void> setRemoteAudioSubscribed(
      String participantIdentity, bool subscribe) async {
    final room = _room;
    if (room == null) return;
    final p = room.remoteParticipants[participantIdentity];
    if (p == null) return;
    try {
      for (final pub in p.audioTrackPublications) {
        if (subscribe) {
          await pub.subscribe();
        } else {
          await pub.unsubscribe();
        }
      }
    } catch (_) {}
  }

  // ------------------------- Allowed speakers management --------------------
  bool _isAllowed(String identity) {
    if (_allowedRemoteSpeakers.isEmpty) return true;
    return _allowedRemoteSpeakers.contains(identity);
  }

  void setAllowRemoteSpeaker(String identity, bool allowed) {
    if (allowed) {
      _allowedRemoteSpeakers.add(identity);
    } else {
      _allowedRemoteSpeakers.remove(identity);
    }
    // Apply subscriptions according to updated policy
    _applySubscriptionForParticipant(identity);
  }

  void setAllowedRemoteSpeakers(Set<String> identities) {
    _allowedRemoteSpeakers
      ..clear()
      ..addAll(identities);
    if (AppConfig.enableLogging) {
      AppLogger.info('Allowed remote speakers set: ${_allowedRemoteSpeakers.join(',')}',
          tag: 'LiveKitAudioService');
    }
    _applySubscriptionsForAll();
  }

  void _applySubscriptionsForAll() {
    final room = _room;
    if (room == null) return;
    for (final p in room.remoteParticipants.values) {
      _applySubscriptionForParticipant(p.identity);
    }
  }

  Future<void> _applySubscriptionForParticipant(String identity) async {
    final room = _room;
    if (room == null) return;
    final p = room.remoteParticipants[identity];
    if (p == null) return;
    final shouldSubscribe = _isAllowed(identity) || identity.startsWith('musicbot_');
    try {
      for (final pub in p.audioTrackPublications) {
        if (pub.kind != lk.TrackType.AUDIO) continue;
        if (shouldSubscribe) {
          if (!pub.subscribed) {
            if (AppConfig.enableLogging) {
              AppLogger.info('Subscribing to remote audio identity=$identity sid=${pub.sid}',
                  tag: 'LiveKitAudioService');
            }
            await pub.subscribe();
          }
        } else {
          if (pub.subscribed) {
            if (AppConfig.enableLogging) {
              AppLogger.info('Unsubscribing from remote audio identity=$identity sid=${pub.sid}',
                  tag: 'LiveKitAudioService');
            }
            await pub.unsubscribe();
          }
        }
      }
    } catch (_) {}
  }
}

// Simple holder for participant audio level observer (top-level)
class _ParticipantLevelObserver {
  final lk.Participant p;
  final VoidCallback cb;
  _ParticipantLevelObserver(this.p, this.cb);
}
